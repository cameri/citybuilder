import * as THREE from 'three';
import { BLUEPRINTS } from '../blueprints/index.js';

export interface OrthoRendererOptions {
  tileSize?: number; // world units per tile
}

export interface PanState {
  isPanning: boolean;
  lastX: number;
  lastY: number;
}

export class OrthoRenderer {
  scene = new THREE.Scene();
  camera: THREE.OrthographicCamera;
  renderer: THREE.WebGLRenderer;
  tileSize: number;
  container: HTMLElement;
  needsResize = true;
  gridGroup = new THREE.Group();
  highlightGroup = new THREE.Group();
  selectionGroup = new THREE.Group();
  infraGroup = new THREE.Group(); // infrastructure (poles, pipes, lines)
  groundGroup = new THREE.Group(); // static ground tiles
  private groundBuilt = false;
  initializedView = false;
  hoveredTile: { x: number; y: number } | null = null;
  // Track the currently active tool so highlight visuals can adapt (e.g., bulldoze = red)
  private activeTool: string | null = null;
  private selectionRect: { x: number; y: number; w: number; h: number; zone?: 'R'|'C'|'I' } | null = null;
  // Bulldoze rectangle (separate from selectionRect used for zoning to allow different coloring)
  private bulldozeRect: { x: number; y: number; w: number; h: number } | null = null;
  private roadLine: { x0: number; y0: number; x1: number; y1: number; blocked?: boolean } | null = null;
  panState: PanState = { isPanning: false, lastX: 0, lastY: 0 };
  mapSize = { width: 16, height: 16 };
  onCameraChange?: () => void;
  private cameraTarget = new THREE.Vector3(0, 0, 0); // persistent target to avoid orientation drift
  private debugCamera = false;
  private lastDebugLog = 0;

  constructor(container: HTMLElement, opts: OrthoRendererOptions = {}) {
    this.container = container;
    this.tileSize = opts.tileSize ?? 1;
    const aspect = container.clientWidth / container.clientHeight || 1;
    const half = 10; // view half-height
    this.camera = new THREE.OrthographicCamera(-half*aspect, half*aspect, half, -half, -100, 100);
  this.camera.position.set(10, 10, 10);
  this.camera.up.set(0,1,0);
  this.camera.lookAt(this.cameraTarget);
  // Enable camera debug logging if localStorage flag set
  try { this.debugCamera = localStorage.getItem('simcity-debug-camera') === '1'; } catch {}
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(this.renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    this.scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.4);
    dir.position.set(5,10,7);
    this.scene.add(dir);
  this.scene.add(this.groundGroup);
  this.scene.add(this.gridGroup);
    this.scene.add(this.highlightGroup);
  this.scene.add(this.selectionGroup);
  this.scene.add(this.infraGroup);

    this.bindPanEvents();
    window.addEventListener('resize', () => this.onResize());
  }

  private bindPanEvents() {
    // Only handle zoom with mouse wheel - panning is handled by mouseHandler.ts
    this.container.addEventListener('wheel', (e) => {
      const zoomSpeed = 0.1;
      const zoom = e.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
      this.zoomCamera(zoom);
      if (this.onCameraChange) {
        this.onCameraChange();
      }
      e.preventDefault();
    });
  }

  panCamera(deltaX: number, deltaY: number) {
    // Interpret deltaX / deltaY as raw pixel movement on the canvas.
    // Convert pixel movement into world-space translation in the XZ plane
    // so that the map drags naturally (mouse drag right -> world appears to move right).

    const w = this.container.clientWidth || 1;
    const h = this.container.clientHeight || 1;
    const frustumWidth = this.camera.right - this.camera.left;   // world units across screen
    const frustumHeight = this.camera.top - this.camera.bottom;  // world units vertically

    const worldPerPixelX = frustumWidth / w;
    const worldPerPixelY = frustumHeight / h;

  // Camera basis vectors: right and a ground-plane 'up' (perpendicular in XZ)
  const right = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 0);
  right.y = 0; right.normalize();
  // Derive ground-plane up perpendicular to right in XZ
  const upGround = new THREE.Vector3(-right.z, 0, right.x).normalize();

  // Pixel deltas to world deltas (grab semantics: drag right -> map follows pointer, so camera moves opposite drag)
  const move = new THREE.Vector3();
  move.addScaledVector(right,  -deltaX * worldPerPixelX);
  move.addScaledVector(upGround, -deltaY * worldPerPixelY);

  this.camera.position.add(move);
  this.cameraTarget.add(move); // keep target fixed relative to camera
  this.realignCamera();
  this.onCameraMoved('pan');
  }

  // Direct world translation helper (dx,dz in world units on ground plane)
  translateCameraWorld(dx: number, dz: number) {
    this.camera.position.x += dx;
    this.camera.position.z += dz;
    this.cameraTarget.x += dx;
    this.cameraTarget.z += dz;
    this.realignCamera();
    this.onCameraMoved('translate');
  }

  zoomCamera(factor: number) {
    const frustumHeight = (this.camera.top - this.camera.bottom);
    const newHeight = frustumHeight * factor;
    const halfHeight = newHeight / 2;
    const aspect = (this.camera.right - this.camera.left) / frustumHeight;

    this.camera.top = halfHeight;
    this.camera.bottom = -halfHeight;
    this.camera.left = -halfHeight * aspect;
    this.camera.right = halfHeight * aspect;
  this.camera.updateProjectionMatrix();
  this.onCameraMoved('zoom');
  }

  centerCameraOnTile(tileX: number, tileY: number) {
    const worldX = tileX * this.tileSize;
    const worldZ = tileY * this.tileSize;

    // Maintain the current camera height and angle
    const currentHeight = this.camera.position.y;
    const offset = new THREE.Vector3(8, 0, 8); // Maintain isometric offset

  this.camera.position.set(worldX + offset.x, currentHeight, worldZ + offset.z);
  this.cameraTarget.set(worldX, 0, worldZ);
  this.realignCamera();
  this.onCameraMoved('centerTile');
  }

  centerCameraOnMap() {
    const centerX = (this.mapSize.width - 1) / 2;
    const centerY = (this.mapSize.height - 1) / 2;
  this.centerCameraOnTile(centerX, centerY);
  }

  getCameraState() {
    const frustumHeight = this.camera.top - this.camera.bottom;

    return {
      position: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z },
      lookAt: { x: this.cameraTarget.x, y: this.cameraTarget.y, z: this.cameraTarget.z },
      zoom: frustumHeight
    };
  }

  setCameraState(state: { position: { x: number; y: number; z: number }, lookAt: { x: number; y: number; z: number }, zoom: number }) {
    // Set camera position
  this.camera.position.set(state.position.x, state.position.y, state.position.z);

    // Set camera zoom (frustum size)
    const halfHeight = state.zoom / 2;
    const aspect = (this.camera.right - this.camera.left) / (this.camera.top - this.camera.bottom);

    this.camera.top = halfHeight;
    this.camera.bottom = -halfHeight;
    this.camera.left = -halfHeight * aspect;
    this.camera.right = halfHeight * aspect;
  this.camera.updateProjectionMatrix();
  this.cameraTarget.set(state.lookAt.x, state.lookAt.y, state.lookAt.z);
  this.realignCamera();
  this.onCameraMoved('setState');
  }

  zoomIn() {
    this.zoomCamera(0.8); // Zoom in by 20%
  }

  zoomOut() {
    this.zoomCamera(1.25); // Zoom out by 25%
  }

  resetZoom() {
    // Reset to default zoom level (20 units frustum height)
    const defaultZoom = 20;
    const halfHeight = defaultZoom / 2;
    const aspect = (this.camera.right - this.camera.left) / (this.camera.top - this.camera.bottom);

    this.camera.top = halfHeight;
    this.camera.bottom = -halfHeight;
    this.camera.left = -halfHeight * aspect;
    this.camera.right = halfHeight * aspect;
  this.camera.updateProjectionMatrix();
  this.onCameraMoved('resetZoom');
  }

  setOnCameraChange(callback: () => void) {
    this.onCameraChange = callback;
  }

  onResize() {
    this.needsResize = true;
  }

  setHoveredTile(x: number | null, y: number | null) {
    if (x === null || y === null) {
      this.hoveredTile = null;
    } else {
      this.hoveredTile = { x, y };
    }
    this.updateHighlight();
  }

  // Allow external UI to inform renderer about current tool for contextual highlighting
  setActiveTool(tool: string) {
    this.activeTool = tool;
    // If a tile is currently hovered, refresh its highlight color immediately
    if (this.hoveredTile) this.updateHighlight();
  }

  private updateHighlight() {
    this.highlightGroup.clear();

    if (this.hoveredTile) {
      const highlightGeom = new THREE.BoxGeometry(this.tileSize * 1.1, 0.3, this.tileSize * 1.1);
  const color = this.activeTool === 'bulldoze' ? 0xff0000 : 0xffffff;
  const highlightMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.3 });
      const highlight = new THREE.Mesh(highlightGeom, highlightMat);
      highlight.position.set(
        this.hoveredTile.x * this.tileSize,
        0.15,
        this.hoveredTile.y * this.tileSize
      );
      this.highlightGroup.add(highlight);
    }

    // Selection rectangle (area zoning preview)
    this.selectionGroup.clear();
    if (this.selectionRect) {
      const { x, y, w, h, zone } = this.selectionRect;
      const colors: Record<string, number> = { R: 0x4caf50, C: 0x2196f3, I: 0xffc107 };
      const color = colors[zone || 'R'] || 0xffffff;
      const geom = new THREE.BoxGeometry(w * this.tileSize * 1.05, 0.31, h * this.tileSize * 1.05);
      const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.18 });
      const mesh = new THREE.Mesh(geom, mat);
      // Center position of rectangle
      const cx = x + (w - 1) / 2;
      const cy = y + (h - 1) / 2;
      mesh.position.set(cx * this.tileSize, 0.155, cy * this.tileSize);
      this.selectionGroup.add(mesh);

      // Outline (edges)
      const edgeGeom = new THREE.BoxGeometry(w * this.tileSize * 1.05, 0.32, h * this.tileSize * 1.05);
      const edges = new THREE.EdgesGeometry(edgeGeom as any);
      const lineMat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.6 });
      const line = new THREE.LineSegments(edges, lineMat);
      line.position.copy(mesh.position);
      this.selectionGroup.add(line);
    }

    // Bulldoze rectangle preview (draw after zoning so it visually overrides)
    if (this.bulldozeRect) {
      const { x, y, w, h } = this.bulldozeRect;
      const color = 0xff0000;
      const geom = new THREE.BoxGeometry(w * this.tileSize * 1.08, 0.34, h * this.tileSize * 1.08);
      const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.18 });
      const mesh = new THREE.Mesh(geom, mat);
      const cx = x + (w - 1) / 2;
      const cy = y + (h - 1) / 2;
      mesh.position.set(cx * this.tileSize, 0.17, cy * this.tileSize);
      this.selectionGroup.add(mesh);
      // Outline
      const edgeGeom = new THREE.BoxGeometry(w * this.tileSize * 1.08, 0.35, h * this.tileSize * 1.08);
      const edges = new THREE.EdgesGeometry(edgeGeom as any);
      const lineMat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.75 });
      const line = new THREE.LineSegments(edges, lineMat);
      line.position.copy(mesh.position);
      this.selectionGroup.add(line);
    }

  // Road / infrastructure line preview
    if (this.roadLine) {
      const { x0, y0, x1, y1, blocked } = this.roadLine;
      // Bresenham's line algorithm
      const tiles = [];
      let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
      let sx = x0 < x1 ? 1 : -1;
      let sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
      let x = x0, y = y0;
      while (true) {
        tiles.push({x, y});
        if (x === x1 && y === y1) break;
        let e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }
      // Draw each tile as a semi-transparent box
  let color = blocked ? 0xff2222 : 0x646cff; // default road preview
  if (this.activeTool === 'infra_powerpole') color = 0xdddddd;
  else if (this.activeTool === 'infra_waterpipe') color = 0x00bcd4;
  else if (this.activeTool === 'infra_gaspipeline') color = 0xff9800;
  const roadMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35 });
      const roadGeom = new THREE.BoxGeometry(this.tileSize*0.95, 0.09, this.tileSize*0.95);
      for (const t of tiles) {
        const mesh = new THREE.Mesh(roadGeom, roadMat);
        mesh.position.set(t.x * this.tileSize, 0.045, t.y * this.tileSize);
        this.selectionGroup.add(mesh);
      }
    }
  }

  setSelectionRect(rect: { x: number; y: number; w: number; h: number; zone?: 'R'|'C'|'I' } | null) {
    this.selectionRect = rect;
    this.updateHighlight();
  }

  setBulldozeRect(rect: { x: number; y: number; w: number; h: number } | null) {
    this.bulldozeRect = rect;
    this.updateHighlight();
  }

  setRoadLine(line: { x0: number; y0: number; x1: number; y1: number; blocked?: boolean } | null) {
    this.roadLine = line;
    this.updateHighlight();
  }

  updateGrid(map: any[][]) {
    // One-time camera centering based on map dimensions
    if (!this.initializedView && map.length && map[0].length) {
      const h = map.length; const w = map[0].length;
      const cx = (w - 1) / 2;
      const cz = (h - 1) / 2;
      // Place camera on a diagonal above center
  this.camera.position.set(cx + 8, Math.max(w, h) * 0.9, cz + 8);
  this.cameraTarget.set(cx, 0, cz);
  this.realignCamera();
  this.onCameraMoved('init');
  // Build ground tile layer (only once per map size)
  this.buildGround(w, h);
      this.initializedView = true;
    }
    // Simple rebuild each frame for now (small maps); optimize later.
    this.gridGroup.clear();
  this.infraGroup.clear();
    const geom = new THREE.BoxGeometry(this.tileSize*0.95, 0.25, this.tileSize*0.95);
    const roadGeom = new THREE.BoxGeometry(this.tileSize*0.95, 0.05, this.tileSize*0.95);
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const overlaySel = (document.getElementById('hudOverlay') as HTMLSelectElement);
  const overlayMode = ((window as any).SIMCITY_OVERLAY_MODE ?? (overlaySel ? overlaySel.value : undefined)) || 'none';
    // Collect poles first for power line connection rendering
    const polePositions: { x: number; y: number }[] = [];
    for (const row of map) for (const tile of row) if (tile.powerPole) polePositions.push({ x: tile.x, y: tile.y });

    for (const row of map) {
      for (const tile of row) {
        if (tile.road) {
          const r = new THREE.Mesh(roadGeom, roadMat);
          r.position.set(tile.x * this.tileSize, 0.025, tile.y * this.tileSize);
          this.gridGroup.add(r);
        }

        // Zone tile rendering (skip only the zone mesh if no zone, but still allow infra below)
        if (tile.zone) {
          let color = 0x222222;
          if (tile.zone === 'R') color = tile.developed ? 0x4caf50 : 0x2e7d32;
          if (tile.zone === 'C') color = tile.developed ? 0x2196f3 : 0x1565c0;
          if (tile.zone === 'I') color = tile.developed ? 0xffc107 : 0xb28704;
        // Overlay tint modifications
  if (overlayMode === 'pollution') {
          const p = Math.min(100, tile.pollution || 0);
          const intensity = p / 100; // 0..1
          // Blend toward red
          const r = ((color >> 16) & 0xff);
          const g = ((color >> 8) & 0xff);
          const b = (color & 0xff);
          const nr = Math.min(255, Math.round(r + (255 - r) * intensity));
          const ng = Math.round(g * (1 - 0.5 * intensity));
          const nb = Math.round(b * (1 - 0.5 * intensity));
          color = (nr << 16) | (ng << 8) | nb;
        } else if (overlayMode === 'landValue') {
          const lv = Math.min(100, tile.landValue || 0);
          const tVal = lv / 100; // 0..1
          // Gradient blue (low) -> green (mid) -> yellow (high)
          let rC=0, gC=0, bC=0;
          if (tVal < 0.5) { // blue->green
            const tt = tVal / 0.5; // 0..1
            rC = 0;
            gC = Math.round(128 * tt + 64);
            bC = Math.round(200 - 200 * tt);
          } else { // green -> yellow
            const tt = (tVal - 0.5) / 0.5;
            rC = Math.round(0 + 200 * tt);
            gC = 192;
            bC = Math.round(0 + 0 * tt);
          }
          color = (rC << 16) | (gC << 8) | bC;
        } else if (overlayMode === 'service') {
          // Service coverage: green if covered, gray if not
          if (tile.coverage && (tile.coverage.power || tile.coverage.education || tile.coverage.health || tile.coverage.safety)) {
            color = 0x00ff00;
          } else {
            color = 0x444444;
          }
        } else if (overlayMode === 'education') {
          const c = tile.coverage?.education || 0;
          if (c === 0) color = 0x222222; else {
            // scale 1..5+ into gradient blue->green->yellow
            const t = Math.min(1, c / 5);
            let rC=0, gC=0, bC=0;
            if (t < 0.5) { // blue->green
              const tt = t / 0.5;
              rC = 0;
              gC = Math.round(200 * tt);
              bC = Math.round(200 - 150 * tt);
            } else { // green->yellow
              const tt = (t - 0.5) / 0.5;
              rC = Math.round(200 * tt);
              gC = 200;
              bC = 50 - Math.round(50 * tt);
            }
            color = (rC << 16) | (gC << 8) | bC;
          }
        } else if (overlayMode === 'health') {
          const c = tile.coverage?.health || 0;
            if (c === 0) color = 0x222222; else {
              const t = Math.min(1, c / 5);
              // gradient red->pink->white
              const rC = 150 + Math.round(105 * t);
              const gC = Math.round(80 + 150 * t);
              const bC = Math.round(80 + 150 * t);
              color = (rC << 16) | (gC << 8) | bC;
            }
        } else if (overlayMode === 'safety') {
          const c = tile.coverage?.safety || 0;
          if (c === 0) color = 0x222222; else {
            const t = Math.min(1, c / 5);
            // gradient dark red -> orange -> bright yellow
            let rC = Math.round(120 + 135 * t);
            let gC = Math.round(20 + 200 * t);
            let bC = Math.round(20 * (1 - t));
            color = (rC << 16) | (gC << 8) | bC;
          }
        } else if (overlayMode === 'gas') {
          // Gas coverage: orange if covered, gray if not
          color = tile.coverage?.gas ? 0xff9800 : 0x444444;
        } else if (overlayMode === 'water') {
          // Water coverage: cyan if covered, gray if not
          color = tile.coverage?.water ? 0x00bcd4 : 0x444444;
        } else if (overlayMode === 'sewage') {
          // Sewage coverage: purple if covered, gray if not
          color = tile.coverage?.sewage ? 0x8e24aa : 0x444444;
        } else if (overlayMode === 'garbage') {
          // Garbage coverage: yellow if covered, gray if not
          color = tile.coverage?.garbage ? 0xffeb3b : 0x444444;
        } else if (overlayMode === 'power') {
          // Power overlay: blue if powered, dark if not
          color = tile.powered ? 0x2196f3 : 0x222233;
        } else if (overlayMode === 'traffic') {
          // Traffic overlay: yellow/red for high load
          const load = Math.min(100, tile.trafficLoad || 0);
          if (load > 0) {
            const intensity = Math.min(1, load / 10);
            // Blend yellow to red
            const r = Math.round(255 * intensity);
            const g = Math.round(255 * (1 - intensity));
            color = (r << 16) | (g << 8);
          }
        }
        const mat = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(geom, mat);
          mesh.position.set(tile.x * this.tileSize, 0.125, tile.y * this.tileSize);
          mesh.userData.tile = tile;
          this.gridGroup.add(mesh);
        }

        // Power pole (simple cylinder) above tile regardless of zone
        if (tile.powerPole) {
          const poleGeom = new THREE.CylinderGeometry(0.08, 0.1, 1.1, 8);
          const poleMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e, metalness: 0.1, roughness: 0.8 });
          const pole = new THREE.Mesh(poleGeom, poleMat);
          pole.position.set(tile.x * this.tileSize, 0.55, tile.y * this.tileSize);
          this.infraGroup.add(pole);
          // Crossarm
          const armGeom = new THREE.BoxGeometry(0.5, 0.05, 0.05);
          const arm = new THREE.Mesh(armGeom, poleMat);
          arm.position.set(tile.x * this.tileSize, 1.05, tile.y * this.tileSize);
          this.infraGroup.add(arm);
          // Insulator nubs
          const nubGeom = new THREE.CylinderGeometry(0.015, 0.015, 0.06, 6);
          const nubMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
          const offsets = [-0.2, 0, 0.2];
          for (const off of offsets) {
            const nub = new THREE.Mesh(nubGeom, nubMat);
            nub.rotation.z = Math.PI/2;
            nub.position.set(tile.x * this.tileSize + off, 1.05, tile.y * this.tileSize);
            this.infraGroup.add(nub);
          }
        }

        // Underground pipes visibility (water -> cyan, gas -> orange) regardless of zone
        const showWater = tile.waterPipe && (overlayMode === 'water' || this.activeTool === 'infra_waterpipe');
        const showGas = tile.gasPipe && (overlayMode === 'gas' || this.activeTool === 'infra_gaspipeline');
        if (showWater || showGas) {
          const pipeHeight = 0.03;
          if (showWater) {
            const matW = new THREE.MeshBasicMaterial({ color: 0x00bcd4 });
            const eastGeom = new THREE.BoxGeometry(this.tileSize * 0.5, pipeHeight, 0.08);
            const east = new THREE.Mesh(eastGeom, matW);
            east.position.set(tile.x * this.tileSize + this.tileSize * 0.25, 0.015, tile.y * this.tileSize + this.tileSize * 0.45);
            this.infraGroup.add(east);
            const southGeom = new THREE.BoxGeometry(0.08, pipeHeight, this.tileSize * 0.5);
            const south = new THREE.Mesh(southGeom, matW);
            south.position.set(tile.x * this.tileSize + this.tileSize * 0.45, 0.015, tile.y * this.tileSize + this.tileSize * 0.25);
            this.infraGroup.add(south);
          }
          if (showGas) {
            const matG = new THREE.MeshBasicMaterial({ color: 0xff9800 });
            const westGeom = new THREE.BoxGeometry(this.tileSize * 0.5, pipeHeight, 0.08);
            const west = new THREE.Mesh(westGeom, matG);
            west.position.set(tile.x * this.tileSize - this.tileSize * 0.25, 0.015, tile.y * this.tileSize - this.tileSize * 0.45);
            this.infraGroup.add(west);
            const northGeom = new THREE.BoxGeometry(0.08, pipeHeight, this.tileSize * 0.5);
            const north = new THREE.Mesh(northGeom, matG);
            north.position.set(tile.x * this.tileSize - this.tileSize * 0.45, 0.015, tile.y * this.tileSize - this.tileSize * 0.25);
            this.infraGroup.add(north);
          }
        }

        // Service buildings and infrastructure buildings (render only at the root tile)
        if (tile.building && tile.buildingRoot && tile.buildingRoot.x === tile.x && tile.buildingRoot.y === tile.y) {
          const bp = BLUEPRINTS[tile.building];
          if (bp && bp.color) {
            const buildingHeight = Math.max(0.5, bp.size.w * bp.size.h * 0.3); // Height scales with size

            let buildingGeom: THREE.BufferGeometry;

            // Check if this is a power station - render as dome
            if (tile.building === 'infra.powerstation' || tile.building === 'svc.power.small') {
              // Create dome geometry for power stations
              const radius = Math.min(bp.size.w, bp.size.h) * this.tileSize * 0.4;
              const heightScale = 0.8; // Make dome slightly flattened
              buildingGeom = new THREE.SphereGeometry(
                radius,
                16, // widthSegments
                8,  // heightSegments
                0,  // phiStart
                Math.PI * 2, // phiLength (full circle)
                0,  // thetaStart
                Math.PI * 0.5 // thetaLength (half sphere for dome)
              );
              buildingGeom.scale(1, heightScale, 1); // Flatten the dome
            } else {
              // Default box geometry for other buildings
              buildingGeom = new THREE.BoxGeometry(
                bp.size.w * this.tileSize * 0.9,
                buildingHeight,
                bp.size.h * this.tileSize * 0.9
              );
            }

            const buildingMat = new THREE.MeshStandardMaterial({
              color: bp.color,
              roughness: 0.8,
              metalness: 0.1
            });
            const building = new THREE.Mesh(buildingGeom, buildingMat);

            // Position at the center of the building footprint
            const centerX = tile.x + (bp.size.w - 1) / 2;
            const centerY = tile.y + (bp.size.h - 1) / 2;

            if (tile.building === 'infra.powerstation' || tile.building === 'svc.power.small') {
              // Position dome on ground level
              const radius = Math.min(bp.size.w, bp.size.h) * this.tileSize * 0.4;
              const heightScale = 0.8;
              building.position.set(
                centerX * this.tileSize,
                radius * heightScale + 0.25, // Position dome base slightly above tile level
                centerY * this.tileSize
              );
            } else {
              building.position.set(
                centerX * this.tileSize,
                buildingHeight / 2 + 0.25, // Slightly above tile level
                centerY * this.tileSize
              );
            }

            building.userData.building = tile.building;
            this.infraGroup.add(building);
          }
        }
      }
    }

    // Power line connections (horizontal & vertical within 5 tiles) with sagging catenary-like curve
    if (polePositions.length) {
      const maxGap = 5;
      const poleSet = new Set(polePositions.map(p => p.x + ',' + p.y));
      const drawn = new Set<string>(); // avoid duplicate both directions
      const makeKey = (a:{x:number;y:number}, b:{x:number;y:number}) => a.x < b.x || (a.x===b.x && a.y < b.y) ? `${a.x},${a.y}-${b.x},${b.y}` : `${b.x},${b.y}-${a.x},${a.y}`;
  const logged = new Set<string>(); // track logged connections this frame

      const addSagLine = (ax:number, ay:number, bx:number, by:number) => {
        const start = new THREE.Vector3(ax * this.tileSize, 0.9, ay * this.tileSize);
        const end = new THREE.Vector3(bx * this.tileSize, 0.9, by * this.tileSize);
        const span = start.distanceTo(end);
        const sag = Math.min(0.35, 0.08 * span); // mild sag proportional to span
        const points: THREE.Vector3[] = [];
        const segments = Math.max(8, Math.floor(span * 6));
        for (let i=0;i<=segments;i++) {
          const t = i/segments; // 0..1
          // simple parabolic sag y = base - sag * 4t(1-t)
            const yOffset = sag * 4 * t * (1 - t); // 0..sag
          const x = THREE.MathUtils.lerp(start.x, end.x, t);
          const z = THREE.MathUtils.lerp(start.z, end.z, t);
          points.push(new THREE.Vector3(x, start.y - yOffset, z));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({ color: 0xe0e0e0 });
        const line = new THREE.Line(geo, mat);
        this.infraGroup.add(line);
      };

      for (const p of polePositions) {
        // Rightward search
        for (let dx=1; dx<=maxGap; dx++) {
          const qx = p.x+dx, qy = p.y;
          if (poleSet.has(qx+','+qy)) {
            const key = makeKey(p,{x:qx,y:qy});
            if (!drawn.has(key)) { drawn.add(key); addSagLine(p.x,p.y,qx,qy); if(!logged.has(key)){ console.debug('[power] connect line', { from: p, to: {x:qx,y:qy} }); logged.add(key);} }
            break; // only connect nearest in this direction
          }
        }
        // Downward search
        for (let dy=1; dy<=maxGap; dy++) {
          const qx = p.x, qy = p.y+dy;
          if (poleSet.has(qx+','+qy)) {
            const key = makeKey(p,{x:qx,y:qy});
            if (!drawn.has(key)) { drawn.add(key); addSagLine(p.x,p.y,qx,qy); if(!logged.has(key)){ console.debug('[power] connect line', { from: p, to: {x:qx,y:qy} }); logged.add(key);} }
            break;
          }
        }
      }
    }
  }

  private buildGround(w: number, h: number) {
    if (this.groundBuilt) return;
    this.groundGroup.clear();
    const tileGeom = new THREE.PlaneGeometry(this.tileSize, this.tileSize);
    // Subtle color palette for ground variation
    const palette = [0x2d2f33, 0x303338, 0x34373c, 0x383c42];
    for (let y=0; y<h; y++) {
      for (let x=0; x<w; x++) {
        // deterministic pseudo-random pick based on coordinates
        const hash = (x * 73856093) ^ (y * 19349663);
        const color = palette[Math.abs(hash) % palette.length];
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 1, metalness: 0 });
        const quad = new THREE.Mesh(tileGeom, mat);
        quad.rotation.x = -Math.PI/2;
        quad.position.set(x * this.tileSize, -0.02, y * this.tileSize);
        this.groundGroup.add(quad);
      }
    }
    // Add a subtle hemisphere light for ambient sky/ground contrast if not already present
    const hasHemi = this.scene.children.some(c => (c as any).isHemisphereLight);
    if (!hasHemi) {
      const hemi = new THREE.HemisphereLight(0xddeeff, 0x222222, 0.35);
      this.scene.add(hemi);
    }
    this.groundBuilt = true;
  }

  frame(map: any[][]) {
    if (this.needsResize) {
      const w = this.container.clientWidth;
      const h = this.container.clientHeight;
      this.renderer.setSize(w, h, false);
      const aspect = w / h;
      const frustumHeight = (this.camera.top - this.camera.bottom);
      this.camera.left = -frustumHeight/2 * aspect;
      this.camera.right = frustumHeight/2 * aspect;
      this.camera.updateProjectionMatrix();
      this.needsResize = false;
    }
    this.updateGrid(map);
    this.renderer.render(this.scene, this.camera);
  }

  private realignCamera() {
    this.camera.up.set(0,1,0); // enforce consistent up
    this.camera.lookAt(this.cameraTarget);
    this.camera.updateMatrixWorld();
  }

  private onCameraMoved(source: string) {
    this.onCameraChange?.();
    if (!this.debugCamera) return;
    const now = performance.now();
    if (now - this.lastDebugLog < 200) return; // throttle logs
    this.lastDebugLog = now;
    const dir = new THREE.Vector3();
    this.camera.getWorldDirection(dir);
    const right = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 0);
    const up = this.camera.up.clone();
    // Determine handedness (positive should remain stable)
    const handedness = right.dot(new THREE.Vector3().copy(up).cross(dir));
    if (handedness < 0) {
      console.warn('[camera] detected negative handedness (possible flip) – realigning', handedness);
      // Attempt corrective realign
      this.camera.up.set(0,1,0);
      this.camera.lookAt(this.cameraTarget);
      this.camera.updateMatrixWorld();
    }
    console.log('[camera]', source, {
      pos: { x: +this.camera.position.x.toFixed(3), y: +this.camera.position.y.toFixed(3), z: +this.camera.position.z.toFixed(3) },
      target: { x: +this.cameraTarget.x.toFixed(3), y: +this.cameraTarget.y.toFixed(3), z: +this.cameraTarget.z.toFixed(3) },
      dir: { x: +dir.x.toFixed(3), y: +dir.y.toFixed(3), z: +dir.z.toFixed(3) },
      up: { x: +up.x.toFixed(3), y: +up.y.toFixed(3), z: +up.z.toFixed(3) },
      handed: +handedness.toFixed(3)
    });
  }
}
